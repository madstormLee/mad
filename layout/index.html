<h1>Layout</h1>

<pre>
여기에는 아무래도 dir/index가 있으면 될 것 같다.

그렇다면,
1. dir/index가 하나의 component 이고,
2. routing 방식이 sitemap이 결정하도록 되어야 한다.

그런데, 2번의 경우는 url주소가 가리키는 곳을 찾기 위해서 sitemap을 반드시 봐야 하는 불편함을 프로그래머에게 줄 수 밖에 없다.
convention을 설정으로 바꿀 수 있는 것은 당연하지만,
굳이 convention을 어겨서 불편함을 감수해야 하는가?

다른 방식으로는, 1번에서 component를 그대로 indexAction에서 사용하는 방법이 있다.

아예, return new Component('dir'); 과 같은 형식으로 가는 것이다.

어차피 dir component를 확인하러 가게 되는 것은 동일하다.
하지만, layout component를 다른 곳에서 사용할 때는 조금 틀리게 된다.
말하자면 모든 설정과 참조가 layout component 자체에 전부 있어야 한다는 것이다.

여기에는 2가지 방법. 즉,
1. config와 sitemap을 component본인이 가지고 있는 방식,
2. 각 action에서 component를 사용하고, defendency를 설정하는 방식
이 유효하게 된다.
(아예 따로 작성하는 방식은 dry하지 않기 때문에 생각하지 않는다.)

결국 어떤 방식이건 간에 gem이나 composer같은 defendency를 가져와야 하는 문제에 봉착할 수 밖에는 없다.


아니면...

혹시 이건 어떤가?
MadController 자체가 기본적인 indexAction을 가지고 있는 것이다.
componentNavi와... model의 index를 구현하는...
model의 기본 index는 directory indexer이고.
왜냐하면, 기본적으로 sitemap이 없을 때, indexer가 해야 할 일은 앞으로 나아갈 길,
즉, component를 알려주는 역할을 해야 하기 때문이다.

결국, index component는 가장 기본적인 MadController와 MadModel, 그리고 MadModel::index를 indexer로 가지고 있는 것이 맞고, MadModel::index는 glob( '*', GLOB_DIRONLY )를 돌려주면 될 것이다.
</pre>
